{"version":3,"sources":["JSONLD/Converter.ts"],"names":[],"mappings":"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","file":"Converter.js","sourcesContent":["import { IllegalArgumentError } from \"../Errors/IllegalArgumentError\";\nimport {\n\tPointer,\n\tPointerLibrary,\n} from \"../Pointer\";\nimport { RDFList } from \"../RDF/List\";\nimport { Serializer } from \"../RDF/Literal/Serializer\";\nimport * as XSDSerializers from \"../RDF/Literal/Serializers/XSD\";\nimport { RDFNode } from \"../RDF/Node\";\nimport { URI } from \"../RDF/URI\";\nimport { XSD } from \"../Vocabularies/XSD\";\nimport * as ObjectSchema from \"./../ObjectSchema\";\nimport {\n\tDigestedObjectSchemaProperty,\n\tPointerType\n} from \"./../ObjectSchema\";\nimport * as Utils from \"./../Utils\";\nimport { guessXSDType } from \"./Utils\";\n\n// TODO: Use Literal.Parsers to parse literals\nexport class JSONLDConverter {\n\tprivate _literalSerializers:Map<string, Serializer>;\n\n\tget literalSerializers():Map<string, Serializer> { return this._literalSerializers; }\n\n\tprivate static getDefaultSerializers():Map<string, Serializer> {\n\t\tlet literalSerializers:Map<string, Serializer> = new Map<string, Serializer>();\n\n\t\tliteralSerializers.set( XSD.date, XSDSerializers.dateSerializer );\n\t\tliteralSerializers.set( XSD.dateTime, XSDSerializers.dateTimeSerializer );\n\t\tliteralSerializers.set( XSD.time, XSDSerializers.timeSerializer );\n\t\tliteralSerializers.set( XSD.integer, XSDSerializers.integerSerializer );\n\t\tliteralSerializers.set( XSD.int, XSDSerializers.integerSerializer );\n\t\tliteralSerializers.set( XSD.unsignedInt, XSDSerializers.unsignedIntegerSerializer );\n\t\tliteralSerializers.set( XSD.long, XSDSerializers.longSerializer );\n\t\tliteralSerializers.set( XSD.unsignedLong, XSDSerializers.unsignedLongSerializer );\n\t\tliteralSerializers.set( XSD.float, XSDSerializers.floatSerializer );\n\t\tliteralSerializers.set( XSD.double, XSDSerializers.floatSerializer );\n\t\tliteralSerializers.set( XSD.boolean, XSDSerializers.booleanSerializer );\n\t\tliteralSerializers.set( XSD.string, XSDSerializers.stringSerializer );\n\n\t\treturn literalSerializers;\n\t}\n\n\tconstructor( literalSerializers?:Map<string, Serializer> ) {\n\t\tthis._literalSerializers = ! ! literalSerializers ? literalSerializers : JSONLDConverter.getDefaultSerializers();\n\t}\n\n\tcompact( expandedObjects:Object[], targetObjects:Object[], digestedSchema:ObjectSchema.DigestedObjectSchema, pointerLibrary:PointerLibrary ):Object[];\n\tcompact( expandedObject:Object, targetObject:Object, digestedSchema:ObjectSchema.DigestedObjectSchema, pointerLibrary:PointerLibrary, strict?:boolean ):Object;\n\tcompact( expandedObjects:Object[], digestedSchema:ObjectSchema.DigestedObjectSchema, pointerLibrary:PointerLibrary ):Object[];\n\tcompact( expandedObject:Object, digestedSchema:ObjectSchema.DigestedObjectSchema, pointerLibrary:PointerLibrary ):Object;\n\tcompact( expandedObjectOrObjects:any, targetObjectOrObjectsOrDigestedContext:any, digestedSchemaOrPointerLibrary:any, pointerLibrary:PointerLibrary = null, strict?:boolean ):any {\n\t\tlet targetObjectOrObjects:any = ! pointerLibrary ? null : targetObjectOrObjectsOrDigestedContext;\n\t\tlet digestedSchema:any = ! pointerLibrary ? targetObjectOrObjectsOrDigestedContext : digestedSchemaOrPointerLibrary;\n\t\tpointerLibrary = ! pointerLibrary ? digestedSchemaOrPointerLibrary : pointerLibrary;\n\n\t\tif( ! Utils.isArray( expandedObjectOrObjects ) ) return this.compactSingle( expandedObjectOrObjects, targetObjectOrObjects, digestedSchema, pointerLibrary, strict );\n\n\t\tlet expandedObjects:Object[] = expandedObjectOrObjects;\n\t\tlet targetObjects:Object[] = ! ! targetObjectOrObjects ? targetObjectOrObjects : [];\n\t\tfor( let i:number = 0, length:number = expandedObjects.length; i < length; i ++ ) {\n\t\t\tlet expandedObject:Object = expandedObjects[ i ];\n\t\t\tlet targetObject:Object = targetObjects[ i ] = ! ! targetObjects[ i ] ? targetObjects[ i ] : {};\n\n\t\t\tthis.compactSingle( expandedObject, targetObject, digestedSchema, pointerLibrary, strict );\n\t\t}\n\n\t\treturn targetObjects;\n\t}\n\n\texpand( compactedObjects:Object[], generalSchema:ObjectSchema.DigestedObjectSchema, digestedSchema:ObjectSchema.DigestedObjectSchema ):RDFNode[];\n\texpand( compactedObject:Object, generalSchema:ObjectSchema.DigestedObjectSchema, digestedSchema:ObjectSchema.DigestedObjectSchema ):RDFNode;\n\texpand( compactedObjectOrObjects:Object[], generalSchema:ObjectSchema.DigestedObjectSchema, digestedSchema:ObjectSchema.DigestedObjectSchema ):any {\n\t\tif( ! Utils.isArray( compactedObjectOrObjects ) ) return this.expandSingle( compactedObjectOrObjects, generalSchema, digestedSchema );\n\t}\n\n\tprivate expandSingle( compactedObject:Object, generalSchema:ObjectSchema.DigestedObjectSchema, digestedSchema:ObjectSchema.DigestedObjectSchema ):RDFNode {\n\t\tlet expandedObject:any = {};\n\n\t\texpandedObject[ \"@id\" ] = ! ! compactedObject[ \"id\" ] ? compactedObject[ \"id\" ] : \"\";\n\t\tif( ! ! compactedObject[ \"types\" ] ) expandedObject[ \"@type\" ] = compactedObject[ \"types\" ].map( ( type:string ) => ObjectSchema.ObjectSchemaUtils.resolveURI( type, generalSchema, { vocab: true, base: true } ) );\n\n\t\tUtils.forEachOwnProperty( compactedObject, ( propertyName:string, value:any ):void => {\n\t\t\tif( propertyName === \"id\" ) return;\n\t\t\tif( propertyName === \"types\" ) return;\n\n\t\t\tconst expandedPropertyName:string = ObjectSchema.ObjectSchemaUtils.resolveURI( propertyName, digestedSchema, { vocab: true } );\n\t\t\tif( URI.isRelative( expandedPropertyName ) ) return;\n\n\t\t\tconst expandedValue:any[] = this.expandProperty( propertyName, value, digestedSchema, generalSchema );\n\t\t\tif( expandedValue === null ) return;\n\n\t\t\texpandedObject[ expandedPropertyName ] = expandedValue;\n\t\t} );\n\n\t\treturn expandedObject;\n\t}\n\n\tprivate expandProperty( propertyName:string, propertyValue:any, digestedSchema:ObjectSchema.DigestedObjectSchema, generalSchema:ObjectSchema.DigestedObjectSchema ):any[] {\n\t\tconst definition:ObjectSchema.DigestedObjectSchemaProperty = digestedSchema.properties.get( propertyName );\n\n\t\tconst propertyContainer:ObjectSchema.ContainerType = definition ? definition.containerType : void 0;\n\t\tif( propertyContainer === ObjectSchema.ContainerType.LANGUAGE ) return this.expandPropertyLanguageMap( propertyValue );\n\n\t\tpropertyValue = Array.isArray( propertyValue ) ? propertyValue : [ propertyValue ];\n\t\tif( propertyContainer === null ) propertyValue = [ propertyValue[ 0 ] ];\n\n\t\tconst propertyType:boolean = definition ? definition.literal : null;\n\t\tconst expandedValues:any[] = propertyType === true ?\n\t\t\tthis.expandPropertyLiteral( propertyValue, definition, digestedSchema ) :\n\t\t\tpropertyType === false ?\n\t\t\t\tthis.expandPropertyPointer( propertyValue, digestedSchema, generalSchema, definition ) :\n\t\t\t\tthis.expandPropertyValue( propertyValue, digestedSchema, generalSchema, definition )\n\t\t;\n\n\t\tconst filteredValues:any[] = expandedValues.filter( value => value !== null );\n\t\tif( ! filteredValues.length ) return null;\n\n\t\tif( propertyContainer === ObjectSchema.ContainerType.LIST ) return [\n\t\t\t{ \"@list\": filteredValues },\n\t\t];\n\n\t\treturn filteredValues;\n\t}\n\n\tprivate expandPropertyValue( propertyValue:any[], digestedSchema:ObjectSchema.DigestedObjectSchema, generalSchema:ObjectSchema.DigestedObjectSchema, definition?:DigestedObjectSchemaProperty ):any[] {\n\t\treturn propertyValue.map( value => this.expandValue( value, digestedSchema, generalSchema, definition ) );\n\t}\n\n\tprivate expandPropertyPointer( propertyValue:any[], digestedSchema:ObjectSchema.DigestedObjectSchema, generalSchema:ObjectSchema.DigestedObjectSchema, definition?:DigestedObjectSchemaProperty ):any[] {\n\t\treturn propertyValue.map( value => this.expandPointerValue( value, digestedSchema, generalSchema, definition ) );\n\t}\n\n\tprivate expandPropertyLiteral( propertyValue:any[], definition:ObjectSchema.DigestedObjectSchemaProperty, digestedSchema:ObjectSchema.DigestedObjectSchema ):any[] {\n\t\tconst literalType:string = ObjectSchema.ObjectSchemaUtils.resolveURI( definition.literalType, digestedSchema, { vocab: true, base: true } );\n\t\tconst expandedValues:any[] = propertyValue.map( value => this.expandLiteralValue( value, literalType ) );\n\n\t\tif( definition.language ) expandedValues.forEach( value => value[ \"@language\" ] = definition.language );\n\n\t\treturn expandedValues;\n\t}\n\n\tprivate expandPropertyLanguageMap( propertyValue:any ):any {\n\t\tif( ! Utils.isObject( propertyValue ) ) {\n\t\t\t// TODO: Warn of data loss\n\t\t\treturn null;\n\t\t}\n\n\t\tlet mapValues:Array<any> = [];\n\t\tUtils.forEachOwnProperty( propertyValue, ( languageTag:string, value:any ):void => {\n\t\t\t// TODO: Validate language tags\n\n\t\t\tlet serializedValue:string = this.literalSerializers.get( XSD.string ).serialize( value );\n\t\t\tmapValues.push( { \"@value\": serializedValue, \"@type\": XSD.string, \"@language\": languageTag } );\n\t\t} );\n\n\t\treturn mapValues;\n\t}\n\n\tprivate expandPointerValue( propertyValue:any, digestedSchema:ObjectSchema.DigestedObjectSchema, generalSchema:ObjectSchema.DigestedObjectSchema, definition?:DigestedObjectSchemaProperty ):RDFNode {\n\t\tconst isString:boolean = Utils.isString( propertyValue );\n\t\tconst id:string = Pointer.is( propertyValue ) ?\n\t\t\tpropertyValue.id :\n\t\t\tisString ?\n\t\t\t\tpropertyValue :\n\t\t\t\tnull;\n\n\t\t// TODO: Warn of data loss\n\t\tif( ! id ) return null;\n\n\t\tconst relativeTo:{ vocab?:boolean, base?:boolean } = definition ?\n\t\t\tdefinition.pointerType === PointerType.VOCAB ? { vocab: true } : { base: true } :\n\t\t\tisString ? { vocab: true } : {}\n\t\t;\n\n\t\tconst resolved:string = ObjectSchema.ObjectSchemaUtils.resolveURI( id, generalSchema, relativeTo );\n\t\treturn { \"@id\": resolved };\n\t}\n\n\tprivate expandValue( propertyValue:any, digestedSchema:ObjectSchema.DigestedObjectSchema, generalSchema:ObjectSchema.DigestedObjectSchema, definition?:DigestedObjectSchemaProperty ):any {\n\t\t// TODO: Lists of lists are not currently supported by the spec\n\t\tif( Utils.isArray( propertyValue ) ) return null;\n\n\t\treturn Pointer.is( propertyValue ) ?\n\t\t\tthis.expandPointerValue( propertyValue, generalSchema, digestedSchema, definition ) :\n\t\t\tthis.expandLiteralValue( propertyValue, guessXSDType( propertyValue ) )\n\t\t\t;\n\t}\n\n\tprivate expandLiteralValue( literalValue:any, literalType:string ):any {\n\t\tif( literalType === null ) return null;\n\n\t\t// TODO: Warn of data loss\n\t\tif( ! this.literalSerializers.has( literalType ) ) return null;\n\n\t\tconst serializedValue:string = this.literalSerializers\n\t\t\t.get( literalType )\n\t\t\t.serialize( literalValue );\n\t\treturn { \"@value\": serializedValue, \"@type\": literalType };\n\t}\n\n\tprivate compactSingle( expandedObject:any, targetObject:any, digestedSchema:ObjectSchema.DigestedObjectSchema, pointerLibrary:PointerLibrary, strict?:boolean ):void {\n\t\tif( ! expandedObject[ \"@id\" ] ) throw new IllegalArgumentError( \"The expandedObject doesn't have an @id defined.\" );\n\n\t\ttargetObject[ \"id\" ] = expandedObject[ \"@id\" ];\n\t\ttargetObject[ \"types\" ] = ! ! expandedObject[ \"@type\" ] ? expandedObject[ \"@type\" ] : [];\n\n\t\tconst propertyURINameMap:Map<string, string> = this.getPropertyURINameMap( digestedSchema );\n\t\tUtils.forEachOwnProperty( expandedObject, ( propertyURI:string, propertyValues:any[] ):void => {\n\t\t\tif( propertyURI === \"@id\" ) return;\n\t\t\tif( propertyURI === \"@type\" ) return;\n\n\t\t\tif( ! propertyURINameMap.has( propertyURI ) && strict ) return;\n\n\t\t\tconst propertyName:string = propertyURINameMap.has( propertyURI ) ?\n\t\t\t\tpropertyURINameMap.get( propertyURI ) :\n\t\t\t\tdigestedSchema.vocab !== null ?\n\t\t\t\t\tURI.getRelativeURI( propertyURI, digestedSchema.vocab ) :\n\t\t\t\t\tpropertyURI\n\t\t\t;\n\n\t\t\tconst targetValue:any = this.getPropertyValue( propertyName, propertyValues, digestedSchema, pointerLibrary );\n\t\t\tif( targetValue === null || targetValue === void 0 ) return;\n\n\t\t\ttargetObject[ propertyName ] = targetValue;\n\t\t} );\n\n\t\treturn targetObject;\n\t}\n\n\tprivate getPropertyContainerType( propertyValues:any ):ObjectSchema.ContainerType {\n\t\tif( propertyValues.length === 1 ) {\n\t\t\tif( RDFList.is( propertyValues[ 0 ] ) ) return ObjectSchema.ContainerType.LIST;\n\t\t} else {\n\t\t\treturn ObjectSchema.ContainerType.SET;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate getPropertyValue( propertyName:string, propertyValues:any[], digestedSchema:ObjectSchema.DigestedObjectSchema, pointerLibrary:PointerLibrary ):any {\n\t\tconst definition:ObjectSchema.DigestedObjectSchemaProperty = digestedSchema.properties.get( propertyName );\n\t\tconst propertyContainer:ObjectSchema.ContainerType = definition ?\n\t\t\tdefinition.containerType :\n\t\t\tthis.getPropertyContainerType( propertyValues );\n\n\t\tif( propertyContainer === ObjectSchema.ContainerType.LANGUAGE ) return RDFNode.getPropertyLanguageMap( propertyValues );\n\n\t\tif( propertyContainer === ObjectSchema.ContainerType.LIST ) {\n\t\t\tconst list:RDFList = RDFNode.getList( propertyValues );\n\n\t\t\tif( ! list ) return null;\n\t\t\tpropertyValues = list[ \"@list\" ];\n\t\t}\n\n\t\tconst propertyType:boolean = definition ? definition.literal : null;\n\t\tif( propertyType === true && definition.language ) {\n\t\t\tpropertyValues = propertyValues.filter( value => value[ \"@language\" ] === definition.language );\n\t\t}\n\n\t\tif( propertyContainer === null ) propertyValues = [ propertyValues[ 0 ] ];\n\n\t\tconst compactedValues:any[] | undefined = propertyType === true ?\n\t\t\tthis.compactPropertyLiteral( propertyValues, definition, digestedSchema ) :\n\t\t\tpropertyType === false ?\n\t\t\t\tRDFNode.getPropertyPointers( propertyValues, pointerLibrary ) :\n\t\t\t\tRDFNode.getProperties( propertyValues, pointerLibrary )\n\t\t;\n\t\tif( ! compactedValues ) return null;\n\n\t\tconst filteredValues:any[] = compactedValues.filter( value => value !== null );\n\t\tif( ! filteredValues.length ) return null;\n\n\t\tif( propertyContainer === null ) return filteredValues[ 0 ];\n\t\treturn filteredValues;\n\t}\n\n\tprivate getPropertyURINameMap( digestedSchema:ObjectSchema.DigestedObjectSchema ):Map<string, string> {\n\t\tconst map:Map<string, string> = new Map<string, string>();\n\t\tdigestedSchema.properties.forEach( ( definition:ObjectSchema.DigestedObjectSchemaProperty, propertyName:string ):void => {\n\t\t\tconst uri:string = ObjectSchema.ObjectSchemaUtils.resolveURI( definition.uri, digestedSchema, { vocab: true } );\n\t\t\tmap.set( uri, propertyName );\n\t\t} );\n\t\treturn map;\n\t}\n\n\tprivate compactPropertyLiteral( propertyValues:any[], definition:ObjectSchema.DigestedObjectSchemaProperty, digestedSchema:ObjectSchema.DigestedObjectSchema ):any[] {\n\t\tconst literalType:string = definition.literalType === null ?\n\t\t\tXSD.string : ObjectSchema.ObjectSchemaUtils.resolveURI( definition.literalType, digestedSchema, { vocab: true, base: true } );\n\n\t\treturn RDFNode.getPropertyLiterals( propertyValues, literalType );\n\t}\n\n}\n"]}