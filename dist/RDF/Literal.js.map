{"version":3,"sources":["RDF/Literal.ts"],"names":[],"mappings":"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","file":"Literal.js","sourcesContent":["import * as Errors from \"../Errors\";\nimport { XSD } from \"../Vocabularies/XSD\";\nimport * as Utils from \"./../Utils\";\n\nimport * as Serializers from \"./Literal/Serializers\";\n\nexport * from \"./Literal/Serializer\";\nexport { Serializers };\n\nexport interface RDFLiteral {\n\t\"@type\"?:string;\n\t\"@value\":string;\n\t\"@language\"?:string;\n}\n\n\nexport interface RDFLiteralFactory {\n\tfrom( value:any ):RDFLiteral;\n\n\n\tparse( value:string, type?:string ):any;\n\n\tparse( literal:RDFLiteral ):any;\n\n\n\tis( value:any ):value is RDFLiteral;\n\n\n\thasType( value:RDFLiteral, type:string ):boolean;\n}\n\nexport const RDFLiteral:RDFLiteralFactory = {\n\tfrom( value:any ):RDFLiteral {\n\t\tif( Utils.isNull( value ) )\n\t\t\tthrow new Errors.IllegalArgumentError( \"Null cannot be converted into a Literal\" );\n\t\tif( ! Utils.isDefined( value ) )\n\t\t\tthrow new Errors.IllegalArgumentError( \"The value is undefined\" );\n\n\t\tlet type:any;\n\n\t\tswitch( true ) {\n\t\t\tcase Utils.isDate( value ):\n\t\t\t\ttype = XSD.dateTime;\n\t\t\t\tvalue = value.toISOString();\n\t\t\t\tbreak;\n\t\t\tcase Utils.isNumber( value ):\n\t\t\t\tif( Utils.isInteger( value ) ) {\n\t\t\t\t\ttype = XSD.integer;\n\t\t\t\t} else {\n\t\t\t\t\ttype = XSD.double;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase Utils.isString( value ):\n\t\t\t\ttype = XSD.string;\n\t\t\t\tbreak;\n\t\t\tcase Utils.isBoolean( value ):\n\t\t\t\ttype = XSD.boolean;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Treat it as an unknown object\n\t\t\t\ttype = XSD.object;\n\t\t\t\tvalue = JSON.stringify( value );\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlet literal:RDFLiteral = { \"@value\": value.toString() };\n\t\tif( type ) literal[ \"@type\" ] = type;\n\n\t\treturn literal;\n\t},\n\n\tparse( valueOrLiteral:string | RDFLiteral, type?:string ):any {\n\t\tlet literalValue:string;\n\t\tif( Utils.isString( valueOrLiteral ) ) {\n\t\t\tliteralValue = valueOrLiteral;\n\t\t} else {\n\t\t\tlet literal:RDFLiteral = valueOrLiteral;\n\t\t\tif( ! literal ) return null;\n\t\t\tif( ! Utils.hasProperty( literal, \"@value\" ) ) return null;\n\n\t\t\ttype = \"@type\" in literal ? literal[ \"@type\" ] : null;\n\t\t\tliteralValue = literal[ \"@value\" ];\n\t\t}\n\n\t\tlet value:any = literalValue;\n\t\tlet parts:string[];\n\t\tswitch( type ) {\n\t\t\t// Dates\n\t\t\tcase XSD.date:\n\t\t\tcase XSD.dateTime:\n\t\t\t\tvalue = new Date( literalValue );\n\t\t\t\tbreak;\n\t\t\tcase XSD.time:\n\t\t\t\tparts = literalValue.match( /(\\d+):(\\d+):(\\d+)\\.(\\d+)Z/ );\n\t\t\t\tvalue = new Date();\n\t\t\t\tvalue.setUTCHours( parseFloat( parts[ 1 ] ), parseFloat( parts[ 2 ] ), parseFloat( parts[ 3 ] ), parseFloat( parts[ 4 ] ) );\n\t\t\t\tbreak;\n\t\t\tcase XSD.duration:\n\t\t\t\t// TODO: Support duration values (create a class or something...)\n\t\t\t\tbreak;\n\t\t\tcase XSD.gDay:\n\t\t\tcase XSD.gMonth:\n\t\t\tcase XSD.gMonthDay:\n\t\t\tcase XSD.gYear:\n\t\t\tcase XSD.gYearMonth:\n\t\t\t\t// TODO: Decide. Should we return it as a Date?\n\t\t\t\tbreak;\n\n\t\t\t// Numbers\n\t\t\tcase XSD.byte :\n\t\t\tcase XSD.decimal :\n\t\t\tcase XSD.int :\n\t\t\tcase XSD.integer :\n\t\t\tcase XSD.long :\n\t\t\tcase XSD.negativeInteger :\n\t\t\tcase XSD.nonNegativeInteger :\n\t\t\tcase XSD.nonPositiveInteger :\n\t\t\tcase XSD.positiveInteger :\n\t\t\tcase XSD.short :\n\t\t\tcase XSD.unsignedLong :\n\t\t\tcase XSD.unsignedInt :\n\t\t\tcase XSD.unsignedShort :\n\t\t\tcase XSD.unsignedByte :\n\t\t\tcase XSD.double :\n\t\t\tcase XSD.float :\n\t\t\t\tvalue = parseFloat( literalValue );\n\t\t\t\tbreak;\n\n\t\t\t// Misc\n\t\t\tcase XSD.boolean :\n\t\t\t\tvalue = Utils.parseBoolean( literalValue );\n\t\t\t\tbreak;\n\t\t\tcase XSD.string:\n\t\t\t\tvalue = literalValue;\n\t\t\t\tbreak;\n\t\t\tcase XSD.object:\n\t\t\t\tvalue = JSON.parse( literalValue );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn value;\n\t},\n\n\tis( value:any ):value is RDFLiteral {\n\t\treturn Utils.hasProperty( value, \"@value\" )\n\t\t\t&& Utils.isString( value[ \"@value\" ] );\n\t},\n\n\thasType( value:RDFLiteral, type:string ):boolean {\n\t\tif( ! value[ \"@type\" ] && type === XSD.string ) return true;\n\t\treturn value[ \"@type\" ] === type;\n\t},\n};\n"]}