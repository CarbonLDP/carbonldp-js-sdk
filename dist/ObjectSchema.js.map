{"version":3,"sources":["ObjectSchema.ts"],"names":[],"mappings":"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","file":"ObjectSchema.js","sourcesContent":["import {\n\tIllegalArgumentError,\n\tInvalidJSONLDSyntaxError,\n} from \"./Errors\";\nimport { URI } from \"./RDF/URI\";\nimport * as Utils from \"./Utils\";\nimport { XSD } from \"./Vocabularies/XSD\";\n\nexport interface ObjectSchemaProperty {\n\t\"@id\"?:string;\n\t\"@type\"?:string;\n\t\"@language\"?:string;\n\t\"@container\"?:string;\n}\n\nexport interface ObjectSchema {\n\t\"@base\"?:string;\n\t\"@vocab\"?:string;\n\t\"@index\"?:object;\n\t\"@language\"?:string;\n\t\"@reverse\"?:object;\n\n\t[ name:string ]:(string | ObjectSchemaProperty);\n}\n\nexport enum ContainerType {\n\tSET,\n\tLIST,\n\tLANGUAGE,\n}\n\nexport enum PointerType {\n\tID,\n\tVOCAB,\n}\n\nexport class DigestedObjectSchemaProperty {\n\turi:string = null;\n\tliteral:boolean = null;\n\tliteralType:string = null;\n\tpointerType:PointerType = null;\n\tlanguage?:string;\n\tcontainerType:ContainerType = null;\n}\n\nexport class DigestedObjectSchema {\n\tbase:string;\n\tlanguage:string;\n\tvocab?:string;\n\tprefixes:Map<string, string>;\n\tproperties:Map<string, DigestedObjectSchemaProperty>;\n\n\tconstructor() {\n\t\tthis.base = \"\";\n\t\tthis.language = null;\n\t\tthis.prefixes = new Map<string, string>();\n\t\tthis.properties = new Map<string, DigestedObjectSchemaProperty>();\n\t}\n\n}\n\nexport interface ObjectSchemaResolver {\n\tgetGeneralSchema():DigestedObjectSchema;\n\n\thasSchemaFor( object:object, path?:string ):boolean;\n\n\tgetSchemaFor( object:object, path?:string ):DigestedObjectSchema;\n}\n\nexport class ObjectSchemaDigester {\n\n\tstatic digestSchema( schema:ObjectSchema ):DigestedObjectSchema;\n\tstatic digestSchema( schemas:ObjectSchema[] ):DigestedObjectSchema;\n\tstatic digestSchema( schemas:ObjectSchema | ObjectSchema[] ):DigestedObjectSchema {\n\t\tif( ! Array.isArray( schemas ) ) return ObjectSchemaDigester._digestSchema( schemas );\n\n\t\tconst digestedSchemas:DigestedObjectSchema[] = schemas\n\t\t\t.map( schema => ObjectSchemaDigester._digestSchema( schema ) );\n\n\t\treturn ObjectSchemaDigester._combineSchemas( digestedSchemas );\n\t}\n\n\tstatic digestProperty( name:string, definition:ObjectSchemaProperty, digestedSchema?:DigestedObjectSchema ):DigestedObjectSchemaProperty {\n\t\tconst digestedDefinition:DigestedObjectSchemaProperty = new DigestedObjectSchemaProperty();\n\n\t\tif( \"@id\" in definition ) {\n\t\t\tconst uri:any = definition[ \"@id\" ];\n\n\t\t\tif( URI.isPrefixed( name ) ) throw new IllegalArgumentError( \"A prefixed property cannot have assigned another URI.\" );\n\t\t\tif( ! Utils.isString( uri ) ) throw new IllegalArgumentError( \"@id needs to point to a string\" );\n\n\t\t\tdigestedDefinition.uri = uri;\n\t\t} else {\n\t\t\tdigestedDefinition.uri = name;\n\t\t}\n\n\t\tif( \"@type\" in definition ) {\n\t\t\tlet type:any = definition[ \"@type\" ];\n\t\t\tif( ! Utils.isString( type ) ) throw new IllegalArgumentError( \"@type needs to point to a string\" );\n\n\t\t\tif( type === \"@id\" || type === \"@vocab\" ) {\n\t\t\t\tdigestedDefinition.literal = false;\n\t\t\t\tdigestedDefinition.pointerType = type === \"@id\" ? PointerType.ID : PointerType.VOCAB;\n\n\t\t\t} else {\n\t\t\t\tif( URI.isRelative( type ) && type in XSD ) type = XSD[ type ];\n\n\t\t\t\tdigestedDefinition.literal = true;\n\t\t\t\tdigestedDefinition.literalType = type;\n\t\t\t}\n\t\t}\n\n\t\tif( \"@language\" in definition ) {\n\t\t\tconst language:string = definition[ \"@language\" ];\n\t\t\tif( language !== null && ! Utils.isString( language ) ) throw new IllegalArgumentError( \"@language needs to point to a string or null.\" );\n\n\t\t\tdigestedDefinition.literal = true;\n\t\t\tdigestedDefinition.language = language;\n\t\t}\n\n\t\tif( \"@container\" in definition ) {\n\t\t\tswitch( definition[ \"@container\" ] ) {\n\t\t\t\tcase \"@set\":\n\t\t\t\t\tdigestedDefinition.containerType = ContainerType.SET;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"@list\":\n\t\t\t\t\tdigestedDefinition.containerType = ContainerType.LIST;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"@language\":\n\t\t\t\t\tif( Utils.isString( digestedDefinition.language ) ) throw new IllegalArgumentError( \"@container cannot be set to @language when the property definition already contains an @language tag.\" );\n\t\t\t\t\tdigestedDefinition.containerType = ContainerType.LANGUAGE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalArgumentError( \"@container needs to be equal to '@list', '@set', or '@language'\" );\n\t\t\t}\n\t\t}\n\n\t\treturn digestedSchema ?\n\t\t\tObjectSchemaUtils.resolveProperty( digestedSchema, digestedDefinition, true ) :\n\t\t\tdigestedDefinition;\n\t}\n\n\tstatic combineDigestedObjectSchemas( digestedSchemas:DigestedObjectSchema[] ):DigestedObjectSchema {\n\t\tif( digestedSchemas.length === 0 ) throw new IllegalArgumentError( \"At least one DigestedObjectSchema needs to be specified.\" );\n\n\t\tdigestedSchemas.unshift( new DigestedObjectSchema() );\n\t\treturn ObjectSchemaDigester._combineSchemas( digestedSchemas );\n\t}\n\n\tstatic _combineSchemas( digestedSchemas:DigestedObjectSchema[] ):DigestedObjectSchema {\n\t\tconst [ targetSchema, ...restSchemas ] = digestedSchemas;\n\n\t\trestSchemas.forEach( schema => {\n\t\t\tif( schema.vocab !== void 0 ) targetSchema.vocab = schema.vocab;\n\t\t\tif( schema.base !== \"\" ) targetSchema.base = schema.base;\n\t\t\tif( schema.language !== null ) targetSchema.language = schema.language;\n\n\t\t\tUtils.MapUtils.extend( targetSchema.prefixes, schema.prefixes );\n\t\t\tUtils.MapUtils.extend( targetSchema.properties, schema.properties );\n\t\t} );\n\n\t\treturn targetSchema;\n\t}\n\n\tprivate static _digestSchema( schema:ObjectSchema ):DigestedObjectSchema {\n\t\tconst digestedSchema:DigestedObjectSchema = new DigestedObjectSchema();\n\n\t\tfor( const propertyName of [ \"@base\", \"@vocab\" ] as [ \"@base\", \"@vocab\" ] ) {\n\t\t\tif( ! (propertyName in schema) ) continue;\n\t\t\tconst value:string = schema[ propertyName ];\n\n\t\t\tif( value !== null ) {\n\t\t\t\tif( ! Utils.isString( value ) ) throw new IllegalArgumentError( `The value of '${ propertyName }' must be a string or null.` );\n\t\t\t\tif( propertyName === \"@vocab\" && value === \"\" ) throw new IllegalArgumentError( `The value of '${ propertyName }' must be an absolute URI.` );\n\t\t\t\tif( ! URI.isAbsolute( value ) && ! URI.isBNodeID( value ) ) throw new IllegalArgumentError( `The value of '${ propertyName }' must be an absolute URI${ propertyName === \"@base\" ? \" or an empty string\" : \"\" }.` );\n\t\t\t}\n\n\t\t\tdigestedSchema[ propertyName.substr( 1 ) ] = value;\n\t\t}\n\t\tdigestedSchema.base = digestedSchema.base || \"\";\n\n\t\tif( \"@language\" in schema ) {\n\t\t\tconst value:string = schema[ \"@language\" ];\n\t\t\tif( value !== null && ! Utils.isString( value ) ) throw new InvalidJSONLDSyntaxError( `The value of '@language' must be a string or null.` );\n\t\t\tdigestedSchema.language = value;\n\t\t}\n\n\t\tfor( const propertyName in schema ) {\n\t\t\tif( ! schema.hasOwnProperty( propertyName ) ) continue;\n\n\t\t\tif( propertyName === \"@reverse\" ) continue;\n\t\t\tif( propertyName === \"@index\" ) continue;\n\t\t\tif( propertyName === \"@base\" ) continue;\n\t\t\tif( propertyName === \"@vocab\" ) continue;\n\t\t\tif( propertyName === \"@language\" ) continue;\n\n\t\t\tlet propertyValue:(string | ObjectSchemaProperty) = schema[ propertyName ];\n\n\t\t\tif( Utils.isString( propertyValue ) ) {\n\t\t\t\tif( URI.isPrefixed( propertyName ) ) throw new IllegalArgumentError( \"A prefixed property cannot be equal to another URI.\" );\n\t\t\t\tdigestedSchema.prefixes.set( propertyName, propertyValue );\n\n\t\t\t} else if( ! ! propertyValue && Utils.isObject( propertyValue ) ) {\n\t\t\t\tconst definition:DigestedObjectSchemaProperty = ObjectSchemaDigester.digestProperty( propertyName, propertyValue );\n\t\t\t\tdigestedSchema.properties.set( propertyName, definition );\n\n\t\t\t} else {\n\t\t\t\tthrow new IllegalArgumentError( \"ObjectSchema Properties can only have string values or object values.\" );\n\t\t\t}\n\t\t}\n\n\t\treturn digestedSchema;\n\t}\n\n}\n\nexport class ObjectSchemaUtils {\n\n\tstatic resolveURI( uri:string, schema:DigestedObjectSchema, relativeTo:{ vocab?:boolean, base?:boolean } = {} ):string {\n\t\tif( uri === null || URI.isAbsolute( uri ) || URI.isBNodeID( uri ) ) return uri;\n\n\t\tconst [ prefix, localName = \"\" ]:[ string, string ] = uri.split( \":\" ) as [ string, string ];\n\n\t\tconst definedReference:string = schema.prefixes.has( prefix ) ?\n\t\t\tschema.prefixes.get( prefix ) : schema.properties.has( prefix ) ?\n\t\t\t\tschema.properties.get( prefix ).uri\n\t\t\t\t: null;\n\t\tif( definedReference !== null && definedReference !== prefix ) {\n\t\t\treturn ObjectSchemaUtils.resolveURI( definedReference + localName, schema, { vocab: true } );\n\t\t}\n\n\t\tif( localName ) return uri;\n\n\t\tif( relativeTo.vocab && Utils.isString( schema.vocab ) ) return schema.vocab + uri;\n\t\tif( relativeTo.base ) return URI.resolve( schema.base, uri );\n\n\t\treturn uri;\n\t}\n\n\tstatic resolveProperty( schema:DigestedObjectSchema, definition:DigestedObjectSchemaProperty, inSame?:boolean ):DigestedObjectSchemaProperty {\n\t\tconst uri:string = definition.uri;\n\t\tconst type:string = definition.literalType;\n\n\t\tconst resolvedURI:string = ObjectSchemaUtils.resolveURI( uri, schema, { vocab: true } );\n\t\tconst resolvedType:string = ObjectSchemaUtils.resolveURI( type, schema, { vocab: true, base: true } );\n\n\t\tif( resolvedURI !== uri || resolvedType !== type ) {\n\t\t\tdefinition = inSame ? definition : Utils.ObjectUtils.clone( definition );\n\t\t\tdefinition.uri = resolvedURI;\n\t\t\tdefinition.literalType = resolvedType;\n\t\t}\n\n\t\treturn definition;\n\t}\n}\n"]}